var searchIndex = {};
searchIndex['maidsafe_utilities'] = {"items":[[0,"","maidsafe_utilities","# MaidSafe Utilities",null,null],[0,"thread","","Utilities related to threading",null,null],[3,"RaiiThreadJoiner","maidsafe_utilities::thread","A RAII style thread joiner. The destruction of an instance of this type will block until\nthe thread it is managing has joined.",null,null],[11,"new","","Create a new instance of self-managing thread joiner",0,{"inputs":[{"name":"raiithreadjoiner"},{"name":"joinhandle"}],"output":{"name":"raiithreadjoiner"}}],[11,"drop","","",0,{"inputs":[{"name":"raiithreadjoiner"}],"output":null}],[0,"event_sender","maidsafe_utilities","Utilities related to event-subsetting",null,null],[3,"EventSender","maidsafe_utilities::event_sender","This structure is coded to achieve event-subsetting. Receivers in Rust are blocking. One cannot\nlisten to multiple receivers at the same time except by using `try_recv` which again is bad for\nthe same reasons spin-lock based on some sleep is bad (wasting cycles, 50% efficienct on an\naverage etc.). Consider a module that listens to signals from various other modules. Different\nmodules want to talk to this one. So one solution is make a common event set and all senders\n(registered in all the interested modules) send events from the same set. This is bad for\nmaintenance. Wrong modules might use events not expected to originate from them since it is just\none huge event-set. Thus there is a need of event-subsetting and distribute this module-wise so\nwe prevent modules from using wrong events, completely by design and code-mechanics. Also we\ndon't want to spawn threads listening to different receivers (which could force to share\nownership and is anyway silly otherwise too). This is what `EventSender` helps to salvage. A\nsimple mechanism that does what a `skip-list` in linked list does. It brings forth a concept of\nan Umbrella event-category and an event subset. The creator of `EventSender` hard-codes the\ncategory for different observers. Each category only links to a particular event-subset and\ntype information of this is put into `EventSender` to during it's construction. Thus when\ndistributed, the modules cannot cheat (do the wrong thing) by trying to fire an event they are\nnot permitted to. Also a single thread listens to many receivers. All problems solved.",null,null],[4,"EventSenderError","","Errors that can be returned by EventSender",null,null],[13,"EventSendError","","Error sending the event subset",1,null],[13,"CategorySendError","","Error sending the event category",1,null],[11,"fmt","","",1,{"inputs":[{"name":"eventsendererror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"eventsender"}],"output":{"name":"eventsender"}}],[11,"new","","Create a new instance of `EventSender`. Category type, category value and EventSubset type\nare baked into `EventSender` to disallow user code from misusing it.",2,{"inputs":[{"name":"eventsender"},{"name":"sender"},{"name":"category"},{"name":"sender"}],"output":{"name":"eventsender"}}],[11,"send","","Fire an allowed event/signal to the observer.",2,{"inputs":[{"name":"eventsender"},{"name":"eventsubset"}],"output":{"name":"result"}}],[14,"unwrap_result!","maidsafe_utilities","A replacement for calling `unwrap()` on a `Result`.",null,null],[14,"unwrap_option!","","A replacement for calling `unwrap()` on an `Option`.",null,null],[14,"thread!","","This macro is intended to be used in all cases where we want to spawn a new thread of execution\nand if that is not possible then panic out.",null,null]],"paths":[[3,"RaiiThreadJoiner"],[4,"EventSenderError"],[3,"EventSender"]]};
initSearch(searchIndex);
